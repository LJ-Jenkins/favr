[{"path":"https://lj-jenkins.github.io/favr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Luke Jenkins Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lj-jenkins.github.io/favr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Luke Jenkins. Author, maintainer.","code":""},{"path":"https://lj-jenkins.github.io/favr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jenkins L (2025). favr: Function Argument Validation R. R package version 0.0.0.9000, https://lj-jenkins.github.io/favr/.","code":"@Manual{,   title = {favr: Function Argument Validation in R},   author = {Luke Jenkins},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://lj-jenkins.github.io/favr/}, }"},{"path":"https://lj-jenkins.github.io/favr/index.html","id":"favr-","dir":"","previous_headings":"","what":"Function Argument Validation in R","title":"Function Argument Validation in R","text":"Function Argument Validation tools R (favr) provides tools validation safe type coercion/recycling function arguments. focus placed clear error messaging.","code":""},{"path":"https://lj-jenkins.github.io/favr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Function Argument Validation in R","text":"abort_if_not() general validation. cast_if_not() recycle_if_not() safe type casting recycling variables. enforce() validation safe type casting recycling variables. schema() validation safe type casting recycling named elements data.frames/lists. enforce_schema() re-evaluate prior schema call attached data.frame/list. add_to_schema() add arguments existing attached schema re-evaluate. favr also provides simple wrappers many rlang predicates enable accept multiple arguments. nearly cases, differentiated replacing is_* prefix are_*.","code":""},{"path":"https://lj-jenkins.github.io/favr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Function Argument Validation in R","text":"can install development version favr GitHub :","code":"# install.packages(\"pak\") pak::pak(\"LJ-Jenkins/favr\")"},{"path":"https://lj-jenkins.github.io/favr/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Function Argument Validation in R","text":"abort_if_not can used validations: cast_if_not recycle_if_not provide safe casting recycling vctrs. Variables provided left hand side expected type/size provided right. Assignment automatically done back environment specified (default caller_env()): enforce allows validations, casting recycling using keyword functions cast, recycle coerce. Formulas needs used non-validations. formulas, c() can used pass multiple objects specific validation/call multiple arguments can given rhs wrapped list(). Assignment occurs back environment specified (default caller_env()). schema provide functionality data-masked arguments data.frames/lists. size data.frame/list whether certain names present can also checked using .names .size arguments. altered data-mask object returned attached class with_schema used add_to_schema() enforce_schema() edit /re-evaluate original schema call. Tidyselect syntax can used lhs formulas. Many wrappers rlang predicates given multiple inputs can passed. Optional argument inputs can flexibly applied inputs using unnamed named vectors/lists.","code":"library(favr, warn.conflicts = FALSE)  f <- \\(x, y) {   abort_if_not(     is.character(x),     \"`{x}` is too short!\" = nchar(x) > 5,     y$x == 1   ) }  f(1L, list(x = 1)) #> Error in `f()`: #> Caused by error in `abort_if_not()`. #> ℹ In argument: `is.character(x)`. #> ! Returned `FALSE`.  f(\"hi\", list(x = 1)) #> Error in `f()`: #> Caused by error in `abort_if_not()`. #> ℹ In argument: `nchar(x) > 5`. #> ! `hi` is too short! x <- 5L y <- 1  cast_if_not(x = double()) recycle_if_not(y = x)  class(x) #> [1] \"numeric\" length(y) #> [1] 5  x <- 1.5  cast_if_not(x = lossy(integer()))  class(x) #> [1] \"integer\"  x <- \"hi\"  cast_if_not(x = integer()) #> Error: #> Caused by error in `cast_if_not()`. #> ℹ In argument: `x = integer()`. #> ! Can't convert `x` <character> to <integer>. li <- list(x = 1.5) y <- 1.5  enforce(   \"{.var li} problem\" = li ~ list(     \\(.x) names(.x) == \"x\",     coerce(type = list(x = integer()), size = 3, lossy = TRUE),     \"list element not 1?\" = ~ length(.x$x) == 1,     \"list itself now length 3\" = ~ length(.x) == 3   ),   \"{.var y} below zero\" = y > 0,   y ~ recycle(10) )  class(li$x) #> [1] \"numeric\" length(li) #> [1] 3 length(y) #> [1] 10  #-- vctrs type/size rules are for all `cast`, `recycle` and `coerce` calls within favr functions  df <- data.frame(x = 1L, y = \"hi\")  enforce(df ~ cast(data.frame(x = integer(), y = double()))) #> Error: #> Caused by error in `enforce()`. #> ℹ In argument: `df ~ cast(data.frame(x = integer(), y = double()))`. #> ! Can't convert `df$y` <character> to match type of `y` <double>.  x <- 1 y <- 1:5  enforce(c(x, y) ~ list(~ .x > 0, recycle(10))) #> Error: #> Caused by error in `enforce()`. #> ℹ In argument: `c(x, y) ~ list(... recycle(10) ...)`. #> ! Can't recycle `y` (size 5) to size 10. data.frame(x = 2) |>   schema(x == 1) #> Error: #> Caused by error in `schema()`. #> ℹ In argument: `x == 1`. #> ! Returned `FALSE`.  data.frame(x = 1L) |>   schema(x ~ cast(double())) |>   (\\(.) class(.$x))() #> [1] \"numeric\"  # recycling is only implemented for lists. list(x = 1, y = 1, z = 1) |>   schema(     x ~ recycle(3),     y ~ recycle(5),     z ~ recycle(vctrs::vec_size(x))   ) |>   lengths() #> x y z  #> 3 5 3  # enforce_schema reapplies the original call. li <- list(x = 1, y = \"hi\") li_with_schema <- schema(li, x == 1, is.character(y)) li_with_schema$y <- 1  enforce_schema(li_with_schema) #> Error: #> Caused by error in `enforce_schema()`. #> ℹ In argument: `is.character(y)`. #> ! Returned `FALSE`.  df <- data.frame(x = 1:2, xx = 3:4) df_with_schema <- schema(df, starts_with(\"x\") ~ cast(integer(), lossy = TRUE)) df_with_schema$x <- c(1.5, 2.5)  enforce_schema(df_with_schema)$x #> [1] 1 2  li_with_schema <- schema(li, c(x, y) ~ recycle(3)) li_with_schema$y <- \"hi\"  enforce_schema(li_with_schema)$y #> [1] \"hi\" \"hi\" \"hi\"  # add_to_schema adds to an existing schema and then re-evaluates. li_with_schema <- li_with_schema |>   add_to_schema(.names = c(\"x\", \"y\"), .size = 2)  li_with_schema <- li_with_schema |>   add_to_schema(y ~ \\(.x) nchar(.x) > 2) #> Error: #> Caused by error in `add_to_schema()`. #> ℹ For named element: `y`. #> ℹ In argument: `y ~ function(.x) nchar(.x) > 2`. #> ! Returned `FALSE`. x <- list() y <- list(1, 2)  are_list(x, y, list()) #>      x      y list()  #>   TRUE   TRUE   TRUE  are_list(x, y, list(), .all = TRUE) #> [1] TRUE  # `.n` is passed to each input. are_list(x, y, list(), .n = 2) #>      x      y list()  #>  FALSE   TRUE  FALSE  # `.n` is passed sequentially. are_list(x, y, list(), .n = c(0, 2, 0)) #>      x      y list()  #>   TRUE   TRUE   TRUE  # `.n` is only passed to `y`, other inputs are passed # the default (NULL). are_list(x, y, list(), .n = c(y = 5)) #>      x      y list()  #>   TRUE  FALSE   TRUE"},{"path":"https://lj-jenkins.github.io/favr/index.html","id":"notes","dir":"","previous_headings":"Examples","what":"Notes","title":"Function Argument Validation in R","text":"favr functions assign environments (cast_if_not, recycle_if_not, enforce) clean-errors occur: favr inspired MATLAB’s arguments block schematic. favr relies heavily imported packages rlang, vctrs, cli tidyselect. predicate functions favr simple wrappers around rlang predicates, credit goes authors. function argument validation focus performance, see checkmate. earlier, unreleased version package called restrictr.","code":"x <- 1L y <- 1L cast_if_not(x = double(), y = character()) |> try() #> Error in (function (...)  : Caused by error in `cast_if_not()`. #> ℹ In argument: `y = character()`. #> ! Can't convert `y` <integer> to <character>. cat(\"Code has errored but `x` has reverted back to:\", class(x)) #> Code has errored but `x` has reverted back to: integer"},{"path":"https://lj-jenkins.github.io/favr/reference/abort_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure the truth of R expressions — abort_if_not","title":"Ensure the truth of R expressions — abort_if_not","text":"expressions ... TRUE, rlang::abort called first expression () TRUE. names expressions can used error message single default error message can given using .message. passed cli::format_inline formatting.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/abort_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure the truth of R expressions — abort_if_not","text":"","code":"abort_if_not(..., .message = NULL, .error_call = caller_env())  abort_if(..., .message = NULL, .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/favr/reference/abort_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure the truth of R expressions — abort_if_not","text":"... number R expressions, evaluate (logical vector ) TRUE error occur. Positive numbers TRUE, even coerced TRUE inside () arithmetic computations R. expressions named, names used error message. .message single default error message non-named expressions. .error_call call environment use error messages (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/abort_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure the truth of R expressions — abort_if_not","text":"NULL, called side effects .","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/abort_if_not.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure the truth of R expressions — abort_if_not","text":"abort_if opposite abort_if_not, .e. expressions evaluate () FALSE error occur. See enforce schema non data-masked data-masked version abort_if_not options size recycling type casting.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/abort_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure the truth of R expressions — abort_if_not","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  abort_if_not(1 == 1, all.equal(pi, 3.14159265), 1 < 2) # all TRUE  m <- matrix(c(1, 3, 3, 1), 2, 2) abort_if_not(m == t(m), diag(m) == rep(1, 2)) # all TRUE  abort_if_not(1) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`. #> ℹ In argument: `1`. #> ! Argument must be <logical>, not <numeric>. # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `1`. # ! Argument must be <logical>, not <numeric>.  # A custom error message can be given for each expression: m[1, 2] <- 12 abort_if_not(\"{.var m} must be {.cls symmetric}\" = m == t(m)) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`. #> ℹ In argument: `m == t(m)`. #> ! `m` must be <symmetric> # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `m == t(m)`. # ! `m` must be <symmetric>  # Alternatively, one error message can be used for all # expressions: abort_if_not(   m[1, 1] == 1,   diag(m) == rep(2, 2),   .message = \"{.var m} has a diagonal of: {diag(m)}\" ) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`. #> ℹ In argument: `diag(m) == rep(2, 2)`. #> ! `m` has a diagonal of: 1 and 1 # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `diag(m) == rep(2, 2)`. # ! `m` must have a diagonal of: 1 and 1  # The `.error_call` argument can be used to specify where the # error occurs, by default this is the caller environment: myfunc <- function(x) abort_if_not(x) myfunc(FALSE) |> try() #> Error in myfunc(FALSE) :  #>   Caused by error in `abort_if_not()`. #> ℹ In argument: `x`. #> ! Returned `FALSE`. # Error in `myfunc()`: # Caused by error in `abort_if_not()`: # ℹ In argument: `x`. # ! Returned `FALSE`.  # abort_if() errors if any argument does not evaluate to # (all) FALSE: abort_if(1 == 1) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if()`. #> ℹ In argument: `1 == 1`. #> ! Returned `TRUE`. # Error: # Caused by error in `abort_if()`: # ℹ In argument: `1 == 1`. # ! Returned `TRUE`.  # Injection can be used: x <- \"my error\" abort_if_not({{ x }} := FALSE) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`. #> ℹ In argument: `FALSE`. #> ! my error abort_if_not(!!x := FALSE) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`. #> ℹ In argument: `FALSE`. #> ! my error abort_if_not(FALSE, .message = \"{x}\") |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`. #> ℹ In argument: `FALSE`. #> ! my error # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `FALSE`. # ! my error x <- list(\"my {.var bang-bang-bang} error\" = FALSE) abort_if_not(!!!x) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`. #> ℹ In argument: `FALSE`. #> ! my `bang-bang-bang` error # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `FALSE`. # ! my `bang-bang-bang` error"},{"path":"https://lj-jenkins.github.io/favr/reference/are-bare-type-predicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Bare type predicates — are-bare-type-predicates","title":"Bare type predicates — are-bare-type-predicates","text":"Wrappers around rlang type predicates allow multiple objects passed. following documentation adapted rlang documentation: predicats check given type return TRUE bare R objects. Bare objects class attributes. example, data frame list, bare list. predicates vectors include .n argument pattern-matching vector length. Like are_atomic() unlike base R .atomic() R < 4.4.0, are_bare_atomic() return TRUE NULL. Starting R 4.4.0, .atomic(NULL) returns FALSE. Unlike base R .numeric(), are_bare_double() returns TRUE floating point numbers.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-bare-type-predicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bare type predicates — are-bare-type-predicates","text":"","code":"are_bare_list(..., .n = NULL, .all = FALSE)  are_bare_atomic(..., .n = NULL, .all = FALSE)  are_bare_vector(..., .n = NULL, .all = FALSE)  are_bare_integer(..., .n = NULL, .all = FALSE)  are_bare_double(..., .n = NULL, .all = FALSE)  are_bare_complex(..., .n = NULL, .all = FALSE)  are_bare_character(..., .n = NULL, .all = FALSE)  are_bare_string(..., .n = NULL, .all = FALSE)  are_bare_logical(..., .n = NULL, .all = FALSE)  are_bare_raw(..., .n = NULL, .all = FALSE)  are_bare_bytes(..., .n = NULL, .all = FALSE)  are_bare_numeric(..., .n = NULL, .all = FALSE)"},{"path":"https://lj-jenkins.github.io/favr/reference/are-bare-type-predicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bare type predicates — are-bare-type-predicates","text":"... Objects tested. .n Expected lengths vectors. .Whether return arguments TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-bare-type-predicates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bare type predicates — are-bare-type-predicates","text":"Named logical, unnamed boolean .TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-bare-type-predicates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bare type predicates — are-bare-type-predicates","text":"optional input .n can given values map arguments .... unnamed vector/list, input must either length number arguments given ..., length 1: recycled number number arguments given .... Alternatively, named vector/list can given, values matching named elements passed type predicate, unmatched names passed NULL.","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/favr/reference/are-bare-type-predicates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bare type predicates — are-bare-type-predicates","text":"","code":"x <- 1 y <- list() class(y) <- c(\"my_class\", class(y)) z <- mean  are_bare_list(x, y, z, list(1)) #>       x       y       z list(1)  #>   FALSE   FALSE   FALSE    TRUE   # `.all` can be given to test if all inputs # evaluate to TRUE are_bare_list(x, y, z, list(1), .all = TRUE) #> [1] FALSE  # scalar inputs to `.n` are recycled to number of inputs are_bare_list(x, y, z, list(1), .n = 2) #>       x       y       z list(1)  #>   FALSE   FALSE   FALSE   FALSE   # inputs to `.n` matching the number of inputs # are applied sequentially are_bare_list(list(), y, list(1, 2, 3), list(1), .n = c(0, 0, 3, 1)) #>        list()             y list(1, 2, 3)       list(1)  #>          TRUE         FALSE          TRUE          TRUE   # named inputs to `.n` are applied to the matching input # names, with the other inputs being given NULL x <- list() are_bare_list(x, y, list(1, 2, 3), list(1), .n = c(x = 5, \"list(1)\" = 2)) #>             x             y list(1, 2, 3)       list(1)  #>         FALSE         FALSE          TRUE         FALSE"},{"path":"https://lj-jenkins.github.io/favr/reference/are-scalar-type-predicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Scalar type predicates — are-scalar-type-predicates","title":"Scalar type predicates — are-scalar-type-predicates","text":"Wrappers around rlang scalar type predicates allow multiple objects passed. following documentation adapted rlang documentation: predicates check given type whether vector \"scalar\", , length 1. addition length check, are_string() are_bool() return FALSE input missing. useful type-checking arguments, function expects single string single TRUE FALSE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-scalar-type-predicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scalar type predicates — are-scalar-type-predicates","text":"","code":"are_scalar_list(..., .all = FALSE)  are_scalar_atomic(..., .all = FALSE)  are_scalar_vector(..., .all = FALSE)  are_scalar_integer(..., .all = FALSE)  are_scalar_double(..., .all = FALSE)  are_scalar_complex(..., .all = FALSE)  are_scalar_character(..., .all = FALSE)  are_string(..., .string = NULL, .all = FALSE)  are_scalar_logical(..., .all = FALSE)  are_bool(..., .all = FALSE)  are_scalar_raw(..., .all = FALSE)  are_scalar_bytes(..., .all = FALSE)"},{"path":"https://lj-jenkins.github.io/favr/reference/are-scalar-type-predicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scalar type predicates — are-scalar-type-predicates","text":"... Objects tested. .Whether return arguments TRUE. .string string/character vector compare inputs.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-scalar-type-predicates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scalar type predicates — are-scalar-type-predicates","text":"Named logical, unnamed boolean .TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-scalar-type-predicates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scalar type predicates — are-scalar-type-predicates","text":"optional input .string can given character vectors map arguments .... unnamed vector/list, input must either length number arguments given ..., length 1: recycled number number arguments given .... Alternatively, named vector/list can given, values matching named elements passed type predicate, unmatched names passed NULL. List inputs can pass different character vectors dot argument. character vector given single argument, TRUE returned least one element equal.","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/favr/reference/are-scalar-type-predicates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scalar type predicates — are-scalar-type-predicates","text":"","code":"x <- 1 y <- list() z <- mean  are_scalar_list(x, y, z, list(1)) #>       x       y       z list(1)  #>   FALSE   FALSE   FALSE    TRUE   # `.all` can be given to test if all inputs # evaluate to TRUE are_list(x, y, z, list(1), .all = TRUE) #> [1] FALSE"},{"path":"https://lj-jenkins.github.io/favr/reference/are-type-predicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Type predicates — are-type-predicates","title":"Type predicates — are-type-predicates","text":"Wrappers around rlang type predicates allow multiple objects passed. following documentation adapted rlang documentation: type predicates aim make type testing R consistent. wrappers around base::typeof(), operate level beneath S3/S4 etc. Compared base R functions: predicates vectors include .n argument pattern-matching vector length. Unlike .atomic() R < 4.4.0, are_atomic() return TRUE NULL. Starting R 4.4.0 .atomic(NULL) returns FALSE. Unlike .vector(), are_vector() tests object atomic vector list. .vector checks presence attributes (name).","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-type-predicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type predicates — are-type-predicates","text":"","code":"are_list(..., .n = NULL, .all = FALSE)  are_atomic(..., .n = NULL, .all = FALSE)  are_vector(..., .n = NULL, .all = FALSE)  are_integer(..., .n = NULL, .all = FALSE)  are_double(..., .n = NULL, .finite = NULL, .all = FALSE)  are_complex(..., .n = NULL, .finite = NULL, .all = FALSE)  are_character(..., .n = NULL, .all = FALSE)  are_logical(..., .n = NULL, .all = FALSE)  are_raw(..., .n = NULL, .all = FALSE)  are_bytes(..., .n = NULL, .all = FALSE)  are_null(..., .all = FALSE)"},{"path":"https://lj-jenkins.github.io/favr/reference/are-type-predicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type predicates — are-type-predicates","text":"... Objects tested. .n Expected lengths vectors. .TRUE, return boolean whether arguments returned TRUE. .finite Whether values vectors finite. non-finite values NA, Inf, -Inf NaN. Setting something NULL can expensive whole vector needs traversed checked.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-type-predicates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type predicates — are-type-predicates","text":"Named logical, unnamed boolean .TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are-type-predicates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Type predicates — are-type-predicates","text":"optional inputs .n .finite can given inputs map arguments .... unnamed vector/list, input must either length number arguments given ..., length 1: recycled number number arguments given .... Alternatively, named vector/list can given, values matching named elements passed type predicate, unmatched names passed NULL.","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/favr/reference/are-type-predicates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Type predicates — are-type-predicates","text":"","code":"x <- 1 y <- list() z <- mean  are_list(x, y, z, list(1)) #>       x       y       z list(1)  #>   FALSE    TRUE   FALSE    TRUE   # `.all` can be given to test if all inputs # evaluate to TRUE are_list(x, y, z, list(1), .all = TRUE) #> [1] FALSE  # scalar inputs to `.n` and `.finite` are # recycled to number of inputs are_list(x, y, z, list(1), .n = 1) #>       x       y       z list(1)  #>   FALSE   FALSE   FALSE    TRUE   # inputs to `.n` and `.finite` matching the # number of inputs are applied sequentially are_list(x, y, z, list(1), .n = c(1, 0, 1, 2)) #>       x       y       z list(1)  #>   FALSE    TRUE   FALSE   FALSE   # named inputs to `.n` and `.finite` are applied # to the matching input names, with the other inputs # being given NULL are_list(x, y, z, list(1), .n = c(y = 1, \"list(1)\" = 2)) #>       x       y       z list(1)  #>   FALSE   FALSE   FALSE   FALSE"},{"path":"https://lj-jenkins.github.io/favr/reference/are_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Are objects empty vectors or NULL? — are_empty","title":"Are objects empty vectors or NULL? — are_empty","text":"objects empty vectors NULL?","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are objects empty vectors or NULL? — are_empty","text":"","code":"are_empty(..., .all = FALSE)"},{"path":"https://lj-jenkins.github.io/favr/reference/are_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are objects empty vectors or NULL? — are_empty","text":"... Objects tested. .Whether return arguments TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_empty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are objects empty vectors or NULL? — are_empty","text":"Named logical, unnamed boolean .TRUE.","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/favr/reference/are_empty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are objects empty vectors or NULL? — are_empty","text":"","code":"x <- 1 y <- NULL z <- list()  are_empty(x, y, z, NULL) #>     x     y     z  NULL  #> FALSE  TRUE  TRUE  TRUE   are_empty(x, y, z, NULL, .all = TRUE) #> [1] FALSE  are_empty(list(NULL)) #> list(NULL)  #>      FALSE"},{"path":"https://lj-jenkins.github.io/favr/reference/are_integerish.html","id":null,"dir":"Reference","previous_headings":"","what":"Are vectors integer-like? — are_integerish","title":"Are vectors integer-like? — are_integerish","text":"Wrappers around rlang type predicates allow multiple objects passed. following documentation adapted rlang documentation: predicates check whether R considers number vector integer-like, according tolerance check (fact delegated C library). function adapted data analysis, see help base::.integer() examples check whole numbers. Things consider checking integer-like doubles: check can expensive whole double vector traversed checked. Large double values may integerish may still coercible integer. integers R support values 2^31 - 1 numbers stored double can much larger.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_integerish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are vectors integer-like? — are_integerish","text":"","code":"are_integerish(..., .n = NULL, .finite = NULL, .all = FALSE)  are_scalar_integerish(..., .n = NULL, .finite = NULL, .all = FALSE)  are_bare_integerish(..., .n = NULL, .finite = NULL, .all = FALSE)"},{"path":"https://lj-jenkins.github.io/favr/reference/are_integerish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are vectors integer-like? — are_integerish","text":"... Objects tested. .n Expected lengths vectors. .finite Whether values vectors finite. non-finite values NA, Inf, -Inf NaN. Setting something NULL can expensive whole vector needs traversed checked. .TRUE, return boolean whether arguments returned TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_integerish.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are vectors integer-like? — are_integerish","text":"Named logical, unnamed boolean .TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_integerish.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Are vectors integer-like? — are_integerish","text":"optional inputs .n .finite can given inputs map arguments .... unnamed vector/list, input must either length number arguments given ..., length 1: recycled number number arguments given .... Alternatively, named vector/list can given, values matching named elements passed type predicate, unmatched names passed NULL.","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/favr/reference/are_integerish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are vectors integer-like? — are_integerish","text":"","code":"x <- 10L y <- 10.0 z <- 10.000001  are_integerish(x, y, z, TRUE) #>     x     y     z  TRUE  #>  TRUE  TRUE FALSE FALSE   #' # `.all` can be given to test if all inputs # evaluate to TRUE are_integerish(x, y, z, TRUE, .all = TRUE) #> [1] FALSE  # scalar inputs to `.n` and `.finite` are # recycled to number of inputs are_integerish(x, y, z, TRUE, .n = 2) #>     x     y     z  TRUE  #> FALSE FALSE FALSE FALSE   # inputs to `.n` and `.finite` matching the # number of inputs are applied sequentially are_integerish(x, y, z, TRUE, .n = c(1, 2, 1, 1)) #>     x     y     z  TRUE  #>  TRUE FALSE FALSE FALSE   # named inputs to `.n` and `.finite` are applied # to the matching input names, with the other inputs # being given NULL are_integerish(x, y, z, TRUE, .n = c(y = 2, \"TRUE\" = 1)) #>     x     y     z  TRUE  #>  TRUE FALSE FALSE FALSE"},{"path":"https://lj-jenkins.github.io/favr/reference/are_named.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object named? — are_named","title":"Is object named? — are_named","text":"Wrappers around rlang predicates allow multiple objects passed. following documentation adapted rlang documentation: are_named() scalar predicate checks objects ... names attribute none names missing empty (NA \"\"). are_named2() like are_named() always returns TRUE empty vectors, even names attribute. words, tests property element vector named. are_named2() composes well names2() whereas are_named() composes names(). have_names() vectorised variant.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_named.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object named? — are_named","text":"","code":"are_named(..., .all = FALSE)  are_named2(..., .all = FALSE)  have_names(..., .all = FALSE)"},{"path":"https://lj-jenkins.github.io/favr/reference/are_named.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object named? — are_named","text":"... Objects tested. .Whether return arguments TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_named.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is object named? — are_named","text":"are_named() are_named2() return named logical, unnamed boolean .TRUE. have_names() vectorised returns list logical vectors whhere long input object. .TRUE have_names(), logical vectors collapsed boolean returned.","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/favr/reference/are_named.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is object named? — are_named","text":"","code":"# are_named() is a scalar predicate about the whole vector of names: x <- c(a = 1, b = 2) are_named(x, c(a = 1, 2)) #>           x c(a = 1, 2)  #>        TRUE       FALSE  are_named(x, c(a = 1, 2), .all = TRUE) #> [1] FALSE  # Unlike are_named2(), are_named() returns `FALSE` for empty vectors # that don't have a `names` attribute. are_named(list(), vector()) #>   list() vector()  #>    FALSE    FALSE  are_named2(list(), vector()) #>   list() vector()  #>     TRUE     TRUE   # have_names() is vectorised y <- c(a = 1, 2) have_names(x, y, c(a = 1, 2, 3)) #> $x #> [1] TRUE TRUE #>  #> $y #> [1]  TRUE FALSE #>  #> $`c(a = 1, 2, 3)` #> [1]  TRUE FALSE FALSE #>  have_names(x, y, c(a = 1, 2, 3), .all = TRUE) #> [1] FALSE  # Empty and missing names are treated as invalid: invalid <- set_names(letters[1:5]) #> Error in set_names(letters[1:5]): could not find function \"set_names\" names(invalid)[1] <- \"\" #> Error: object 'invalid' not found names(invalid)[3] <- NA #> Error: object 'invalid' not found  are_named(invalid) #> Error: object 'invalid' not found have_names(invalid) #> Error: object 'invalid' not found  # A data frame normally has valid, unique names # but a matrix usually doesn't because the names # are stored in a different attribute. mat <- matrix(1:4, 2) colnames(mat) <- c(\"a\", \"b\") are_named(mtcars, mat) #> mtcars    mat  #>   TRUE  FALSE  have_names(mtcars, mat) #> $mtcars #>  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #>  #> $mat #> [1] FALSE FALSE FALSE FALSE #>"},{"path":"https://lj-jenkins.github.io/favr/reference/are_true.html","id":null,"dir":"Reference","previous_headings":"","what":"Are objects TRUE or FALSE? — are_true","title":"Are objects TRUE or FALSE? — are_true","text":"Test number inputs TRUE FALSE. Inputs passed isTRUE isFALSE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_true.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are objects TRUE or FALSE? — are_true","text":"","code":"are_true(..., .all = FALSE)  are_false(..., .all = FALSE)"},{"path":"https://lj-jenkins.github.io/favr/reference/are_true.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are objects TRUE or FALSE? — are_true","text":"... Objects tested. .Whether return arguments TRUE.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/are_true.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are objects TRUE or FALSE? — are_true","text":"Named logical, unnamed boolean .TRUE.","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/favr/reference/are_true.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are objects TRUE or FALSE? — are_true","text":"","code":"x <- TRUE y <- 1 z <- mean  are_true(x, y, z, TRUE, 0) #>     x     y     z  TRUE     0  #>  TRUE FALSE FALSE  TRUE FALSE   are_true(x, y, z, TRUE, 0, .all = TRUE) #> [1] FALSE  are_false(x, y, z, TRUE, 0) #>     x     y     z  TRUE     0  #> FALSE FALSE FALSE FALSE FALSE   are_false(x, y, z, TRUE, 0, .all = TRUE) #> [1] FALSE"},{"path":"https://lj-jenkins.github.io/favr/reference/cast_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast objects to a given type — cast_if_not","title":"Cast objects to a given type — cast_if_not","text":"names ... expressions, variables within .env envrionment, attempted casted type specified expression: e.g., name_of_object_to_cast = object_of_type_to_cast_to. Expressions evaluated environment specified objects assigned back environment. Lossy casting can undertaken wrapping expression call lossy, e.g., x = lossy(integer()). type conversion vctrs package thus sticks vctrs type conversion rules.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/cast_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast objects to a given type — cast_if_not","text":"","code":"cast_if_not(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/favr/reference/cast_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast objects to a given type — cast_if_not","text":"... number named R expressions. .env environment use evaluation casting expressions assignment casted objects. .error_call call environment use error messages (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/cast_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast objects to a given type — cast_if_not","text":"NULL, objects named ... changed .env environment specified.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/cast_if_not.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cast objects to a given type — cast_if_not","text":"See abort_if_not general validation, recycle_if_not recycling, enforce schema non data-masked data-masked validations, recycling casting.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/cast_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cast objects to a given type — cast_if_not","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  x <- 1L cast_if_not(x = double()) class(x) # \"numeric\" #> [1] \"numeric\"  # By default, lossy casting is not allowed: x <- c(1, 1.5) cast_if_not(x = integer()) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `cast_if_not()`. #> ℹ In argument: `x = integer()`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 2 # Error: # Caused by error in `cast_if_not()`: # ℹ In argument: `x = integer()`. # ! Can't convert from `x` <double> to <integer> due to loss of precision. # ✖ • Locations: 2  # lossy casting can be enabled using `lossy()` call: cast_if_not(x = lossy(integer())) class(x) #> [1] \"integer\" # \"integer\"  # Other objects can be used as the type to cast to, e.g.: x <- 1L y <- 2.3 cast_if_not(x = y) class(x) #> [1] \"numeric\" # \"numeric\"  # Changed objects are available immediately: x <- y <- 1L cast_if_not(x = double(), y = x) cat(class(x), class(y), sep = \", \") #> numeric, numeric # numeric, numeric  myfunc <- \\(x) {   cast_if_not(x = double())   class(x) } x <- 1L myfunc(x) # x is cast to double within the function #> [1] \"numeric\" class(x) # x is still an integer outside the function #> [1] \"integer\"  # The `.env` argument determines the expression and assignment # environment: x <- 1L e <- new.env() e$x <- 1L cast_if_not(x = 1.5, .env = e) cat(   \"environment 'e'\", class(e$x), \"local environment\", class(x),   sep = \", \" ) #> environment 'e', numeric, local environment, integer # environment 'e', numeric, local environment, integer  # Named objects (lhs) are checked to be in the `.env` environment, # throwing an error if not found: x <- 1L e <- new.env() cast_if_not(x = 1.5, .env = e) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `cast_if_not()`. #> ! Object `x` is not found in the `.env` environment specified. # Error: # Caused by error in `cast_if_not()`. # ! Object `x` is not found in the `.env` environment specified.  # For expressions (rhs), the `.env` argument is preferentially # chosen, but if not found then the normal R scoping rules # apply: x <- 1.5 e <- new.env() e$z <- 1L cast_if_not(z = x, .env = e) class(e$z) #> [1] \"numeric\" # \"numeric\"  # The `.error_call` argument can be used to specify where the # error occurs, by default this is the caller environment: myfunc <- function(x) cast_if_not(x = character()) myfunc(FALSE) |> try() #> Error in myfunc(FALSE) :  #>   Caused by error in `cast_if_not()`. #> ℹ In argument: `x = character()`. #> ! Can't convert `x` <logical> to <character>. # Error in `myfunc()`: # Caused by error in `cast_if_not()`: # ℹ In argument: `x = character()`. # ! Can't convert `x` <logical> to <character>.  # Injection can be used: y <- 1L x <- \"y\" cast_if_not(!!x := double()) |> try() class(y) #> [1] \"numeric\" # \"numeric\" y <- 1L x <- list(y = double()) cast_if_not(!!!x) class(y) #> [1] \"numeric\" # \"numeric\"  # Objects are reverted to their original values if an error # occur: x <- y <- 1L cast_if_not(x = double(), y = character()) |> try() # errors #> Error in eval(expr, envir) :  #>   Caused by error in `cast_if_not()`. #> ℹ In argument: `y = character()`. #> ! Can't convert `y` <integer> to <character>. class(x) # integer #> [1] \"integer\""},{"path":"https://lj-jenkins.github.io/favr/reference/enforce.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure the truth of R expressions and cast/recycle objects. — enforce","title":"Ensure the truth of R expressions and cast/recycle objects. — enforce","text":"expressions ... TRUE, rlang::abort called first () TRUE. Alternatively, rlang::formulas can used pass multiple objects validation formulas/functions, /attempt safe type casting size recycling  using cast, recycle coerce functions. rhs formulas can given list pass multiple functions/formulas/calls. Expressions evaluated environment specified objects assigned back environment. Type casting recycling undertaken using vctrs package thus apply vctrs type size rules.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/enforce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure the truth of R expressions and cast/recycle objects. — enforce","text":"","code":"enforce(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/favr/reference/enforce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure the truth of R expressions and cast/recycle objects. — enforce","text":"... number R expressions formulas evaluated. Expressions must evaluate logical whilst formulas can use c lhs either functions formulas evaluate logical, one type/size functions: cast, recycle coerce rhs. rhs formula can also list multiple functions/formulas/calls. expression named, list element rhs formula named, name passed cli::format_inline used error message. .env environment use evaluation expressions assignment objects. .error_call call environment use error messages (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/enforce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure the truth of R expressions and cast/recycle objects. — enforce","text":"NULL, objects casted/recycled ... changed .env environment specified.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/enforce.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure the truth of R expressions and cast/recycle objects. — enforce","text":"See abort_if_not validations schema data-masked version function.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/enforce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure the truth of R expressions and cast/recycle objects. — enforce","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  x <- 1L y <- \"hi\" z <- \\(x) x > 1 enforce(x == 1, is.character(y), is.function(z)) # all TRUE  enforce(x == 2) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `enforce()`. #> ℹ In argument: `x == 2`. #> ! Returned `FALSE`. # Error: # Caused by error in `enforce()`: # ℹ In argument: `x == 2`. # ! Returned `FALSE`.  # A custom error message can be given for each expression by # naming it: enforce(   \"{.var y} must be {.cls numeric}, check input\" = is.numeric(y) ) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `enforce()`. #> ℹ In argument: `is.numeric(y)`. #> ! `y` must be <numeric>, check input # Error: # Caused by error in `enforce()`: # ℹ In argument: `is.numeric(y)`. # ! `y` must be <numeric>, check input  # Formulas can be used to take pass multiple objects # on the lhs, with functions/additional formulas required on # the rhs: enforce(   \"multiple objects using: {.fn c}\" = c(x, y) ~ is.integer ) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `enforce()`. #> ℹ For named element: `y`. #> ℹ In argument: `c(x, y) ~ is.integer`. #> ! multiple objects using: `c()` # Error: # Caused by error in `enforce()`: # ℹ For named element: `y`. # ℹ In argument: `c(x, y) ~ is.integer`. # ! multiple objects using: `c()`  # Formulas can also be used with `cast()`, `recycle()`, and # `coerce()` on the rhs to safely cast or recycle objects: enforce(x ~ cast(double())) class(x) # x is now numeric #> [1] \"numeric\" enforce(x ~ recycle(5)) length(x) # x is now length 5 #> [1] 5 enforce(y ~ coerce(type = factor(), size = 5)) print(y) # y is now factor and length 5 #> [1] hi hi hi hi hi #> Levels: hi  # Multiple calls can be used with formulas by wrapping them # in `list()`, with the names of list elements being # preferentially chosen for error messaging and the error # message also showing which formula/function/call caused the # error: enforce(   \"generic message\" = c(x, y, z) ~ list(     Negate(is.null),     \"{.var specific} message\" = Negate(is.function)   ) ) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `enforce()`. #> ℹ For named element: `z`. #> ℹ In argument: `c(x, y, z) ~ list(... Negate(is.function) ...)`. #> ! `specific` message # Error: # Caused by error in `enforce()`: # ℹ For named element: `z`. # ℹ In argument: `c(x, y, z) ~ list(... Negate(is.function) ...)`. # ! `specific` message  # Changed elements are available immediately: x <- y <- 1L enforce(x ~ cast(double()), y ~ cast(x)) cat(class(x), class(y)) # both now \"numeric\" #> numeric numeric  # The `.error_call` argument can be used to specify where the # error occurs, by default this is the caller environment: myfunc <- function(...) enforce(...) myfunc(x > 4) |> try() #> Error in myfunc(x > 4) : Caused by error in `enforce()`. #> ℹ In argument: `x > 4`. #> ! Returned `FALSE`. # Error in `myfunc()`: # Caused by error in `enforce()`. # ℹ In argument: `x > 4`. # ! Returned `FALSE`.  # rlang injection can be used: msg <- \"{.var injection} msg\" cols <- quote(c(x, y)) enforce(!!msg := !!cols ~ is.integer) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `enforce()`. #> ℹ For named element: `x`. #> ℹ In argument: `c(x, y) ~ is.integer`. #> ! `injection` msg # Error: # Caused by error in `enforce()`: # ℹ For named element: `x`. # ℹ In argument: `c(x, y) ~ is.integer`. # ! `injection` msg  # Objects are reverted to their original values if an error # occur: x <- y <- 1L enforce(   x ~ cast(double()), y ~ recycle(5), y ~ is.function ) |> try() # errors #> Error in eval(expr, envir) :  #>   Caused by error in `enforce()`. #> ℹ In argument: `y ~ is.function`. #> ! Returned `FALSE`. class(x) # integer #> [1] \"integer\" length(y) # 1 #> [1] 1"},{"path":"https://lj-jenkins.github.io/favr/reference/favr_casting_recycling_helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"favr casting and recycling helpers — favr_casting_recycling_helpers","title":"favr casting and recycling helpers — favr_casting_recycling_helpers","text":"function signal favr functions undergo casting, lossy casting, /recycling. can used wihtin calls specific favr functions error used outside . Specifically: lossy(): used within cast_if_not() lossy casting. cast(): used within enforce() schema() casting. recycle(): used within enforce() schema() recycling. coerce(): used within enforce() schema() casting recycling.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/favr_casting_recycling_helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"favr casting and recycling helpers — favr_casting_recycling_helpers","text":"","code":"lossy(x)  cast(x, lossy = FALSE)  recycle(x)  coerce(type = NULL, size = NULL, lossy = FALSE)"},{"path":"https://lj-jenkins.github.io/favr/reference/favr_casting_recycling_helpers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"favr casting and recycling helpers — favr_casting_recycling_helpers","text":"","code":"x <- 1.5 cast_if_not(x = lossy(integer())) class(x) # integer #> [1] \"integer\"  enforce(x ~ list(cast(double()), recycle(5))) class(x) # numeric #> [1] \"numeric\" length(x) # 5 #> [1] 5  x <- 1.5 enforce(x ~ coerce(type = integer(), size = 5, lossy = TRUE)) class(x) # integer #> [1] \"integer\" length(x) # 5 #> [1] 5"},{"path":"https://lj-jenkins.github.io/favr/reference/recycle_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Recycle objects to a given size — recycle_if_not","title":"Recycle objects to a given size — recycle_if_not","text":"names ... expressions, variables within .env envrionment, attempted recycled size specified expression: e.g., name_of_object_to_recycle = size_to_recycle_to. Expressions evaluated environment specified objects assigned back environment. object recycling vctrs package thus stick vctrs recycling rules.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/recycle_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recycle objects to a given size — recycle_if_not","text":"","code":"recycle_if_not(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/favr/reference/recycle_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recycle objects to a given size — recycle_if_not","text":"... number named R expressions. .env environment use evaluation recycling expressions assignment recycled objects. .error_call call environment use error messages (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/recycle_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recycle objects to a given size — recycle_if_not","text":"NULL, objects named ... changed .env environment specified.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/recycle_if_not.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Recycle objects to a given size — recycle_if_not","text":"See abort_if_not general validation, recycle_if_not recycling, enforce schema non data-masked data-masked validations, recycling casting.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/recycle_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recycle objects to a given size — recycle_if_not","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  x <- 1 recycle_if_not(x = 5) length(x) # 5 #> [1] 5  # recycle_if_not() follows `vctrs` recycling rules: x <- c(1, 1) recycle_if_not(x = 6) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `recycle_if_not()`. #> ℹ In argument: `x = 6`. #> ! Can't recycle `x` (size 2) to size 6. # Error: # Caused by error in `recycle_if_not()`: # ℹ In argument: `x = 6`. # ! Can't recycle `x` (size 2) to size 6.  # Beware when using other objects as the size argument, e.g.: x <- 1L y <- c(1, 1, 1) recycle_if_not(x = y) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `recycle_if_not()`. #> ℹ In argument: `x = y`. #> ! Size argument must be positive scalar integerish, not length `3`. # Error: # Caused by error in `recycle_if_not()`: # ℹ In argument: `x = y`. # ! Size argument must be positive scalar integerish, not length `3`.  # When using other objects, call vctrs::vec_size() on them first: recycle_if_not(x = vctrs::vec_size(y)) length(x) #> [1] 3 # 3  # Changed objects are available immediately: x <- y <- 1 recycle_if_not(x = 3, y = vctrs::vec_size(x)) cat(length(x), length(y), sep = \", \") #> 3, 3 # 3, 3  myfunc <- \\(x) {   recycle_if_not(x = 3)   length(x) } x <- 1L myfunc(x) # x is recycled to length 3 within the function #> [1] 3 length(x) # x is still scalar outside the function #> [1] 1  # The `.env` argument determines the expression and assignment # environment: x <- 1 e <- new.env() e$x <- 1 recycle_if_not(x = 3, .env = e) cat(   \"environment 'e'\", length(e$x), \"local environment\", length(x),   sep = \", \" ) #> environment 'e', 3, local environment, 1 # environment 'e', 3, local environment, 1  # Named objects (lhs) are checked to be in the `.env` environment, # throwing an error if not found: x <- 1 e <- new.env() recycle_if_not(x = 3, .env = e) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `recycle_if_not()`. #> ! Object `x` is not found in the `.env` environment specified. # Error: # Caused by error in `recycle_if_not()`. # ! Object `x` is not found in the `.env` environment specified.  # For expressions (rhs), the `.env` argument is preferentially # chosen, but if not found then the normal R scoping rules # apply: x <- 3 e <- new.env() e$z <- 1 recycle_if_not(z = x, .env = e) length(e$z) #> [1] 3 # 3  # The `.error_call` argument can be used to specify where the # error occurs, by default this is the caller environment: myfunc <- function(x) recycle_if_not(x = -5) myfunc(1) |> try() #> Error in myfunc(1) : Caused by error in `recycle_if_not()`. #> ℹ In argument: `x = -5`. #> ! Size argument must be positive scalar integerish, not `-5`. # Error in `myfunc()`: # Caused by error in `recycle_if_not()`: # ℹ In argument: `x = -5`. # ! Size argument must be positive scalar integerish, not `-5`.  #' # Injection can be used: y <- 1L x <- \"y\" recycle_if_not(!!x := 5) |> try() length(y) #> [1] 5 # 5 y <- 1L x <- list(y = 5) recycle_if_not(!!!x) length(y) #> [1] 5 # 5  # Objects are reverted to their original values if an error # occur: x <- y <- 1L recycle_if_not(x = 5, y = -5) |> try() # errors #> Error in eval(expr, envir) :  #>   Caused by error in `recycle_if_not()`. #> ℹ In argument: `y = -5`. #> ! Size argument must be positive scalar integerish, not `-5`. length(x) # 1 #> [1] 1"},{"path":"https://lj-jenkins.github.io/favr/reference/schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure the truth of data-masked R expressions and cast/recycle named elements. — schema","title":"Ensure the truth of data-masked R expressions and cast/recycle named elements. — schema","text":"expressions ..., evaluated within data mask data (see rlang::args_data_masking), TRUE, rlang::abort called first () TRUE. Alternatively, rlang::formulas can used take advantage tidyselect features pass multiple named elements data validation formulas/functions, /attempt safe type casting size recycling using cast, recycle coerce functions. rhs formulas can given list pass multiple functions/formulas/calls. .names .size arguments can also used check given names size data.frame/list . Type casting, size checking, recycling undertaken using vctrs package thus apply vctrs type size rules.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure the truth of data-masked R expressions and cast/recycle named elements. — schema","text":"","code":"schema(data, ...)  # S3 method for class 'list' schema(   data,   ...,   .names = NULL,   .size = NULL,   .error_call = caller_env(),   .darg = caller_arg(data) )  # S3 method for class 'data.frame' schema(   data,   ...,   .names = NULL,   .size = NULL,   .error_call = caller_env(),   .darg = caller_arg(data) )  enforce_schema(data, ...)  # S3 method for class 'with_schema' enforce_schema(data, ..., .error_call = caller_env(), .darg = caller_arg(data))  add_to_schema(data, ...)  # S3 method for class 'with_schema' add_to_schema(   data,   ...,   .names = NULL,   .size = NULL,   .error_call = caller_env(),   .darg = caller_arg(data) )"},{"path":"https://lj-jenkins.github.io/favr/reference/schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure the truth of data-masked R expressions and cast/recycle named elements. — schema","text":"data data.frame list use data mask. ... number R expressions formulas evaluated using data data mask. Formulas can use tidyselect syntax lhs either functions formulas evaluate logical, one type/size functions: cast, recycle coerce rhs. rhs formula can also list multiple functions/formulas/calls. expression named, list element rhs formula named, name passed cli::format_inline used error message. .names character vector names must present data data.frame/list. .size positive scalar integerish value size data data.frame/list must . .error_call call environment use error messages (passed rlang::abort). .darg argument name data use error messages.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure the truth of data-masked R expressions and cast/recycle named elements. — schema","text":"data returned attached class with_schema attribute schema containing schema call enforced later.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure the truth of data-masked R expressions and cast/recycle named elements. — schema","text":"See abort_if_not non-data-masked validation tool enforce non-data-masked version function.","code":""},{"path":"https://lj-jenkins.github.io/favr/reference/schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure the truth of data-masked R expressions and cast/recycle named elements. — schema","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1L, y = \"hi\", z = \\(x) x > 1) li <- li |>   schema(x == 1, is.character(y), is.function(z)) # all TRUE  # The schema call is attached to the returned object and # can be re-evaluated using enforce_schema(): li <- enforce_schema(li) # no error li2 <- li li2$x <- 2L enforce_schema(li2) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `enforce_schema()`. #> ℹ In argument: `x == 1`. #> ! Returned `FALSE`. # Error: # Caused by error in `enforce_schema()`: # ℹ In argument: `x == 1`. # ! Returned `FALSE`.  # Calling `schema()` again overwrites any existing schema. # Alternatively use `add_to_schema()` to add arguments to # an existing schema (.size overwrites, other args append): li <- li |>   add_to_schema(is.numeric(x), .names = c(\"x\", \"y\"), .size = 3)  # A custom error message can be given for each expression by # naming it: schema(li,   \"{.var y} must be {.cls numeric}, check input\" = is.numeric(y) ) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`. #> ℹ In argument: `is.numeric(y)`. #> ! `y` must be <numeric>, check input # Error: # Caused by error in `schema()`: # ℹ In argument: `is.numeric(y)`. # ! `y` must be <numeric>, check input  # Formulas can be used to take advantage of tidyselect features # on the lhs, with functions/additional formulas required on # the rhs: schema(li,   \"multiple columns: {.pkg tidyselect}\" = c(x, y) ~ is.integer ) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`. #> ℹ For named element: `y`. #> ℹ In argument: `c(x, y) ~ is.integer`. #> ! multiple columns: tidyselect # Error: # Caused by error in `schema()`: # ℹ For named element: `y`. # ℹ In argument: `c(x, y) ~ is.integer`. # ! multiple columns: tidyselect  # Formulas can also be used with `cast()`, `recycle()`, and # `coerce()` on the rhs to safely cast or recycle named # elements: class(schema(li, x ~ cast(double()))$x) # x is now numeric #> [1] \"numeric\" length(schema(li, x ~ recycle(5))$x) # x is now length 5 #> [1] 5 schema(   li,   y ~ coerce(type = factor(), size = 5) )$y # y is now factor and length 5 #> [1] hi hi hi hi hi #> Levels: hi  # Multiple calls can be used with formulas by wrapping them # in `list()`, with the names of list elements being # preferentially chosen for error messaging and the error # message also showing which formula/function/call caused the # error: schema(   li,   \"generic message\" = c(x, y, z) ~ list(     Negate(is.null),     \"{.var specific} message\" = Negate(is.function)   ) ) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`. #> ℹ For named element: `z`. #> ℹ In argument: `c(x, y, z) ~ list(... Negate(is.function) ...)`. #> ! `specific` message # Error: # Caused by error in `schema()`: # ℹ For named element: `z`. # ℹ In argument: `c(x, y, z) ~ list(... Negate(is.function) ...)`. # ! `specific` message  # Changed elements are available immediately: df <- data.frame(x = 1L, y = 1L) lapply(schema(df, x ~ cast(double()), y ~ cast(x)), class) #> $x #> [1] \"numeric\" #>  #> $y #> [1] \"numeric\" #>  # both now \"numeric\"  # `.names` and `.size` arguments can be used to check that given # names are present and that the data has the desired size: schema(li, .names = c(\"a\", \"x\", \"y\", \"b\")) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`. #> ! Named elements `a` and `b` not found in data mask `li`. # Error: # Caused by error in `schema()`. # ! Named elements `a` and `b` not found in data mask `li`.  schema(li, .size = 5) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`. #> ! Object `li` is of vctrs size `3`, not `5`. # Error: # Caused by error in `schema()`. # ! Object `li` is of vctrs size `3`, not `5`.  # The `.error_call` argument can be used to specify where the # error occurs, by default this is the caller environment: myfunc <- function(x, ...) schema(x, ...) myfunc(li, x > 4) |> try() #> Error in myfunc(li, x > 4) : Caused by error in `schema()`. #> ℹ In argument: `x > 4`. #> ! Returned `FALSE`. # Error in `myfunc()`: # Caused by error in `schema()`: # ℹ In argument: `x > 4`. # ! Returned `FALSE`.  # rlang pronouns and injection can be used, but care must be # taken when using `.env` and `enforce_schema()` as the # caller environment may have changed: msg <- \"{.var injection} msg\" cols <- quote(c(x, y)) schema(li, !!msg := !!cols ~ is.integer) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`. #> ℹ For named element: `y`. #> ℹ In argument: `c(x, y) ~ is.integer`. #> ! `injection` msg # Error: # Caused by error in `schema()`: # ℹ For named element: `y`. # ℹ In argument: `c(x, y) ~ is.integer`. # ! `injection` msg  x <- 1L li <- schema(li, x == .env$x) # no error x <- 2 enforce_schema(li) |>   try() # error as the environmental variable has changed #> Error in eval(expr, envir) :  #>   Caused by error in `enforce_schema()`. #> ℹ In argument: `x == .env$x`. #> ! Returned `FALSE`. # Error: # Caused by error in `enforce_schema()`: # ℹ In argument: `x == .env$x`. # ! Returned `FALSE`."}]
