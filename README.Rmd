---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# favr <img id="logo" src="man/figures/logo.png" align="right" width="17%" height="17%" />

<!-- badges: start -->
  [![R-CMD-check](https://github.com/LJ-Jenkins/favr/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/LJ-Jenkins/favr/actions/workflows/R-CMD-check.yaml)
  <!-- badges: end -->

Function Argument Validation for R (favr) provides tools for the succinct validation and safe type coercion/recycling of function arguments. A focus is placed on clear error messaging.

## Overview

* `abort_if_not()` for general validation.
* `cast_if_not()` and `recycle_if_not()` for safe type casting and recycling of variables.
* `enforce()` for validation and safe type casting and recycling of variables.
* `schema()` for the validation and safe type casting and recycling of named elements of data.frames/lists.
* `enforce_schema()` to re-evaluate a prior schema call that was attached to the data.frame/list.
* `add_to_schema()` add arguments to an existing attached schema and re-evaluate.

favr also provides simple wrappers for many [rlang](https://rlang.r-lib.org/index.html) predicates that enable them to accept multiple arguments. In nearly all cases, these are differentiated by replacing the `is_*` prefix with `are_*`.

Any predicate function/expression that returns a `logical`, or raises an error, will work with favr validations:

```{r logi/error example, error=TRUE}
library(favr, warn.conflicts = FALSE)

x <- c(1L, 2L)
y <- data.frame(x = "hi")

abort_if_not(
  "{.var x} is not scalar integerish" = rlang::is_scalar_integerish(x)
)

schema(y, x + 1 > 2)
```

## Installation

```r
# Install the latest version of favr from CRAN.

install.packages("favr")

# Or install the development version of favr from GitHub.

# install.packages("pak")
pak::pak("LJ-Jenkins/favr")
```

## Usage

`abort_if_not` can be used for all validations:

```{r abort_if_not example, error=TRUE}
f <- \(x, y) {
  abort_if_not(
    is.character(x),
    "`{x}` is too short!" = nchar(x) > 5,
    y$x == 1
  )
}

f(1L, list(x = 1))

f("hi", list(x = 1))
```

`cast_if_not` and `recycle_if_not` provide safe casting and recycling from [vctrs](https://vctrs.r-lib.org/). Variables are given on the left hand side (name of the argument) and the expected type/size is given on the right (input). Assignment is automatically done back into the environment specified (default is the [caller_env()](https://rlang.r-lib.org/reference/stack.html)):

```{r cast_if_not and recycle_if_not examples, error=TRUE}
x <- 5L
y <- 1

cast_if_not(x = double())
recycle_if_not(y = x)

class(x)
length(y)

x <- 1.5

cast_if_not(x = lossy(integer()))

class(x)

x <- "hi"

cast_if_not(x = integer())
```

`enforce` allows both validations, casting and recycling using the keyword functions of `cast`, `recycle` and `coerce`. [rlang formulas](https://rlang.r-lib.org/reference/is_formula.html) need to be used for casting/recycling, and `c()` can be used in formulas to pass multiple objects to validations/calls. Multiple validations/calls can be given on the rhs of a formula when wrapped in `list()`. Assignment occurs back into the environment specified (default is the [caller_env()](https://rlang.r-lib.org/reference/stack.html)).

```{r enforce example, error=TRUE}
li <- list(x = 1.5)
y <- 1.5

enforce(
  "{.var li} problem" = li ~ list(
    \(.x) names(.x) == "x",
    coerce(type = list(x = integer()), size = 3, lossy = TRUE),
    "list element not 1?" = ~ length(.x$x) == 1,
    "list itself now length 3" = ~ length(.x) == 3
  ),
  "{.var y} below zero" = y > 0,
  y ~ recycle(10)
)

class(li$x)
length(li)
length(y)

#-- vctrs type/size rules are for all `cast`, `recycle` and `coerce` calls within favr functions

df <- data.frame(x = 1L, y = "hi")

enforce(df ~ cast(data.frame(x = integer(), y = double())))

x <- 1
y <- 1:5

enforce(c(x, y) ~ list(~ .x > 0, recycle(10)))
```

`schema` provide the same functionality for data-masked arguments from data.frames/lists. The size of the data.frame/list and whether certain names are present can also be checked using the `.names` and `.size` arguments. The altered data-mask object is returned with an attached class `with_schema` which is used by `add_to_schema()` and `enforce_schema()` to edit and/or re-evaluate the original schema call. [Tidyselect syntax](https://tidyselect.r-lib.org/reference/language.html) can be used on the lhs of formulas.

```{r schema examples, error=TRUE}
data.frame(x = 2) |>
  schema(x == 1)

data.frame(x = 1L) |>
  schema(x ~ cast(double())) |>
  (\(.) class(.$x))()

# recycling is only implemented for lists.
list(x = 1, y = 1, z = 1) |>
  schema(
    x ~ recycle(3),
    y ~ recycle(5),
    z ~ recycle(vctrs::vec_size(x))
  ) |>
  lengths()

# enforce_schema reapplies the original call.
li <- list(x = 1, y = "hi")
li_with_schema <- schema(li, x == 1, is.character(y))
li_with_schema$y <- 1

enforce_schema(li_with_schema)

df <- data.frame(x = 1:2, xx = 3:4)
df_with_schema <- schema(df, starts_with("x") ~ cast(integer(), lossy = TRUE))
df_with_schema$x <- c(1.5, 2.5)

enforce_schema(df_with_schema)$x

li_with_schema <- schema(li, c(x, y) ~ recycle(3))
li_with_schema$y <- "hi"

enforce_schema(li_with_schema)$y

# add_to_schema adds to an existing schema and then re-evaluates.
li_with_schema <- li_with_schema |>
  add_to_schema(.names = c("x", "y"), .size = 2)

li_with_schema <- li_with_schema |>
  add_to_schema(y ~ \(.x) nchar(.x) > 2)
```

Many wrappers of [rlang](https://rlang.r-lib.org) predicates are given so that multiple inputs can be passed. Optional argument inputs can be flexibly applied to all or some inputs by using unnamed or named vectors/lists.

```{r rlang-predicates example}
x <- list()
y <- list(1, 2)

are_list(x, y, list())

are_list(x, y, list(), .all = TRUE)

# `.n` is passed to each input.
are_list(x, y, list(), .n = 2)

# `.n` is passed sequentially.
are_list(x, y, list(), .n = c(0, 2, 0))

# `.n` is only passed to `y`, other inputs are passed
# the default (NULL).
are_list(x, y, list(), .n = c(y = 5))
```

###  Notes

favr functions that assign into environments (`cast_if_not`, `recycle_if_not`, and `enforce`) all do clean-up when errors occur:

```{r clean-up example}
x <- 1L
y <- 1L
cast_if_not(x = double(), y = character()) |> try()
cat("Code has errored but `x` has reverted back to:", class(x))
```

favr was inspired by MATLAB's arguments block and [schematic](https://whipson.github.io/schematic/). favr relies heavily on the imported packages [rlang](https://rlang.r-lib.org), [vctrs](https://vctrs.r-lib.org/), [cli](https://cli.r-lib.org/) and [tidyselect](https://tidyselect.r-lib.org/). All predicate functions in favr are simple wrappers around [rlang](https://rlang.r-lib.org) predicates, for which all credit goes to those authors. For function argument validation that focuses on performance, see [checkmate](https://mllg.github.io/checkmate/). An earlier, unreleased version of this package was called [restrictr](https://github.com/LJ-Jenkins/restrictr).

## Code of Conduct

Please note that the favr project is released with a [Contributor Code of Conduct](https://lj-jenkins.github.io/favr/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.
